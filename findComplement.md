# 问题分析 #
    给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

    注意:

    给定的整数保证在32位带符号整数的范围内。

    你可以假定二进制数不包含前导零位。
    
# 代码实现 #
```C
int findComplement(int num) {
    int i,j=0,t,n=0;
    //int *s=(int*)malloc(sizeof(int)*32);
    char s[32]={0};
    t=num;
    if(num==1)
    {
        return 0;
    }
    else
    {
        while(t!=0)
        {
            i=t%2;
            s[j++]=i;
            t=t/2;
        }
       while(j>0)
       {
            i=s[--j];
            if(i==0)
            {
                i=1; 
            }
            else
            {
                i=0;
            }
            n=i*pow(2,j)+n;
       }
    }
    return n;
}
```
# 总结体会 #
    求解数字的补数。现将数字转换为二进制的数，不断除以2取余数，直到商为0为止，保存在数组中。二

    进制的数应该为倒序，再转化为十进制数字时应该倒序求解2的幂，返回所求解的十进制数字。另外，

    补数的求解能够通过位运算来进行。
