# 问题分析 #

    一个长度为 n + 1 的整形数组，其中的数字都在 1 到 n 之间，包括 1 和 n ，可知至少有一个

    重复的数字存在。假设只有一个数字重复，找出这个重复的数字。

    注意：

    不能更改数组内容（假设数组是只读的）。
    只能使用恒定的额外空间，即要求空间复杂度是 O(1) 。
    时间复杂度小于 O(n2)
    数组中只有一个数字重复，但它可能不止一次重复出现。

# 代码实现 #
```C
int findDuplicate(int* nums, int numsSize) {
    int i,j,res;
    for(i=0;i<numsSize;i++)
    {
        for(j=0;j<numsSize;j++)
        {
            if(nums[i]==nums[j]  && i!=j)
            {
                res=nums[i];
                break;
            }
        }
    }
    return res;
}
```
# 总结体会 #
     寻找重复的元素，采用for嵌套循环，将各元素逐一比较，如果存在相等的元素就返回该元素，跳出循环。虽然重复元素会出现很多次，但是只要出现两次即为重复。 