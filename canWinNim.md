# 问题分析 #

    你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 

    拿掉最后一块石头的人就是获胜者。你作为先手。

    你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

# 代码实现 #
```C
bool canWinNim(int n) {
    return !(n%4==0);
}
```
# 总结体会 #
     假设一推里面有n个石头，每次可以取 1-m 个石头。

     显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一

     次拿走剩余的物品，后者取胜。假设这个石头推为 (m+1)的倍数，那么第一个人取k( 1 <= k <=m)个，

     只要第二个人取 (m+1-k)个石头，那么必定状态能回到最初的状态，m+1个。因为每个人都是很聪

    明的，取的石头的个数一定要对自己有利。那么，假设最初石头推不为 (m+1)的倍数。n=（m+1）r+s，

    那么第一个人只要取s个石头必定能获得胜利，反之，如果s == 0 ，那么第一个人必输。

    即，若n=k*(m+1)，则后取着胜，反之，存在先取者获胜的取法。n%(m+1)==0. 先取者必败。

    就本题而言，每次可取1-3个石头，那么石头个数如果为4的倍数，则自己必败。故只要不是4的倍

    数，就有获胜的可能。